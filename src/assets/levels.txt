/**
format:
[level]: (scene) => {
	return [{
		icon: 'map icon image',
		obstacles: [
			'obstacle name', // see obstacles.txt for list
			{
				// unique hard-coded obstacle; see obstacles.txt for format
			}
		]
	}]
}
*/
(() => {
	// cards
	const initialDeck = [
		'Kindling',
		'Staunch Defender',
		'Snooze',
		'Labelled Potion',
		'Slash',
		'Twin Daggers',
		'Magic Blast',
		'Bonk',
		'Holy Barrier',
	];

	// obstacles
	const basic = [['bat'], ['rat_small']];
	const tough = [
		['bat', 'bat'],
		['rat_small', 'bat'],
		['bat', 'rat_small'],
		['bat', 'rat_small2'],
		['rat_small2'],
		['skeleton'],
		['skeleton_armoured'],
		['rat_big'],
		['zombie'],
		['slime_medium'],
	];
	const annoying = [['jester'], ['kangaroo'], ['bomb']];
	const tougher = [
		['skeleton', 'skeleton_armoured', 'skeleton'],
		['skeleton_armoured', 'skeleton_armoured'],
		['skeleton_armoured', 'slime_medium'],
		['bat', 'skeleton', 'bat'],
		['bat', 'skeleton_armoured', 'bat'],
		['zombie', 'zombie', 'zombie'],
		['zombie', 'skeleton', 'zombie'],
		['zombie', 'skeleton_armoured', 'zombie'],
		['jester', 'bomb'],
		['jester', 'jester', 'potion'],
		['rat_small', 'rat_big', 'rat_small'],
	];
	const encounter = [
		['fountain'],
		['treasure'],
		['potion'],
		['fortune_teller'],
		['dealer'],
		['mini_camp'],
		['trap'],
	];
	const restore = [['fountain'], ['potion']];
	const npc = [['fortune_teller'], ['dealer']];
	const minibosses = [
		['mushroom'],
		['necromancer2'],
		['necromancer2'],
		['The Rat Kings'],
		['slime_big'],
	];
	let minibossOrder = minibosses.slice();
	return {
		0: (scene) => {
			minibossOrder = scene.shuffle(minibosses);
			minibossOrder[minibossOrder.findIndex((i) => i[0] === 'necromancer2')] = [
				'necromancer',
			];
			minibossOrder.unshift(undefined);
			scene.setBg('bg_forest');
			scene.addCard('Advance');
			scene.addParty({ name: 'Priest', spr: 'cat', maxHealth: 3 });
			scene.addParty({ name: 'Mage', spr: 'frog', maxHealth: 2 });
			scene.addParty({ name: 'Knight', spr: 'onion', maxHealth: 4 });
			scene.addParty({
				name: 'Rogue',
				spr: 'apple',
				maxHealth: 2,
				damage: 2,
			});
			initialDeck.forEach((i) => scene.addDeck(i));

			if (scene.started) {
				scene.setFg('blank');
				// skip tutorial
				scene.log('But they fall\nagain and again.');
				return [
					{
						icon: 'icon_cleared',
					},
					{
						icon: 'icon_unknown',
						obstacles: [
							{
								sprite: 'peach',
								interact(scene) {
									scene.loot([
										{
											name: 'Luck Charm',
											sprite: 'Blessed Rain',
											variant: 'instant',
											effect() {
												scene.log('"Good luck slaying the immortal dragon!"');
												scene.whiteout();
												scene.killObstacle();
											},
										},
									]);
								},
							},
						],
					},
					{
						icon: 'icon_door',
						obstacles: ['door'],
					},
				];
			}
			scene.started = true;
			scene.setFg('black');
			scene.containerUI.visible = false;
			scene.queue.push(async () => {
				scene.log(
					'Somewhere outside a small village, nestled deep in the wood...'
				);
				if (!scene.debug) {
					await scene.delay(5000);
					scene.log('An immortal dragon makes its den.');
					await scene.delay(5000);
					scene.log('The village calls on heroes: Noble, strong, and good...');
					await scene.delay(5000);
					scene.log('But they fall\nagain and again.');
					scene.killObstacle();
					await scene.delay(5000);
				}
				scene.containerUI.visible = true;
				scene.blackout(2000);
				scene.setFg('blank');
			});
			return [
				{
					icon: 'icon_unknown',
				},
				{
					icon: 'icon_unknown',
					obstacles: [
						'skeleton',
						{
							sprite: 'peach',
							start(scene) {
								scene.log('"Ahh! Monster!! HELP!!!"');
							},
							interact(scene) {
								scene.queue.push(async () => {
									this.interacted = this.interacted || 0;
									if (this.interacted === 0) {
										scene.log(
											'"Thanks for saving me, but your friend looks hurt..."'
										);
										await scene.delay(2000);
										scene.log('"Here, I brought this for emergencies:"');
										await scene.delay(1000);
										scene.clearHand();
										scene.addCard({
											name: 'Store-\nbought Revive',
											description:
												'Maybe you should have brought some of these...',
											sprite: 'Absolve Death',
											effect: (scene) => {
												++this.interacted;
												scene.sfx('sfx2');
												scene.party[0].heal(2);
											},
										});
										scene.addCard('Advance');
										++this.interacted;
									} else if (this.interacted === 1) {
										scene.log(
											'"You should give that to your friend right away, they look hurt!"'
										);
									} else if (this.interacted === 2) {
										scene.queue.push(async () => {
											scene.log('"You must be here to save the village..."');
											await scene.delay(2000);
											scene.log(
												'"I came here to see you off, and give you this:"'
											);
											scene.loot([
												{
													name: 'Luck Charm',
													sprite: 'Blessed Rain',
													variant: 'instant',
													effect() {
														scene.log(
															"The party immediately feels something change, but it's not clear what..."
														);
														scene.whiteout();
													},
												},
											]);
											++this.interacted;
										});
									} else if (this.interacted === 3) {
										scene.log('"Good luck slaying the immortal dragon!"');
										scene.killObstacle();
									}
								});
							},
						},
					],
				},
				{
					icon: 'icon_door',
					obstacles: ['door'],
				},
			];
		},
		1: (scene) => {
			scene.setBg('bg');
			scene.setFg('fg');
			scene
				.delay(1000)
				.then(() => {
					scene.log('A resounding voice echoes around you:');
					return scene.delay(1000);
				})
				.then(() => {
					scene.log(
						`"BWAHAHA!! WELCOME... TO YOUR ${
							scene.shuffle(['DOOM', 'DEATH', 'DEMISE', 'DOWNFALL'])[0]
						}!!!"`
					);
				});
			const areas = [
				{
					icon: 'icon_camp',
				},
			];
			areas.push(
				{
					icon: 'icon_enemy',
					obstacles: scene.shuffle(basic)[0],
				},
				...scene.shuffle([
					Math.random() > 0.5 && {
						icon: 'icon_enemy',
						obstacles: scene.shuffle(tough)[0],
					},
					Math.random() > 0.5 && {
						icon: 'icon_enemy',
						obstacles: scene.shuffle(basic)[0],
					},
					Math.random() > 0.5 && {
						icon: 'icon_unknown',
						obstacles: scene.shuffle(encounter)[0],
					},
				]),
				...scene.shuffle([
					Math.random() > 0.5 && {
						icon: 'icon_unknown',
						obstacles: scene.shuffle(restore)[0],
					},
					Math.random() > 0.5 && {
						icon: 'icon_enemy',
						obstacles: scene.shuffle(basic)[0],
					},
				])
			);
			areas.push(
				{
					icon: 'icon_unknown',
					obstacles: ['shrine'],
				},
				{
					icon: 'icon_boss',
					obstacles: minibossOrder[scene.level],
				},
				{
					icon: 'icon_treasure',
					obstacles: ['treasure'],
				},
				{
					icon: 'icon_door',
					obstacles: ['door'],
				}
			);
			return areas.filter((i) => i);
		},
		2: (scene) => {
			const areas = [
				{
					icon: 'icon_camp',
				},
			];
			areas.push(
				{
					icon: 'icon_enemy',
					obstacles: scene.shuffle(basic)[0],
				},
				...scene.shuffle([
					{
						icon: 'icon_unknown',
						obstacles: ['treasure'],
					},
					{
						icon: 'icon_enemy',
						obstacles: scene.shuffle(tough.concat(annoying))[0],
					},
					Math.random() > 0.5 && {
						icon: 'icon_enemy',
						obstacles: scene.shuffle(basic)[0],
					},
					Math.random() > 0.5 && {
						icon: 'icon_enemy',
						obstacles: scene.shuffle(tough)[0],
					},
				]),
				Math.random() > 0.5 && {
					icon: 'icon_unknown',
					obstacles: scene.shuffle(restore)[0],
				},
				Math.random() > 0.5 && {
					icon: 'icon_enemy',
					obstacles: scene.shuffle(basic)[0],
				}
			);
			areas.push(
				{
					icon: 'icon_unknown',
					obstacles: ['shrine'],
				},
				{
					icon: 'icon_boss',
					obstacles: minibossOrder[scene.level],
				},
				{
					icon: 'icon_treasure',
					obstacles: ['treasure'],
				},
				{
					icon: 'icon_door',
					obstacles: ['door'],
				}
			);
			return areas.filter((i) => i);
		},
		3: (scene) => {
			const areas = [
				{
					icon: 'icon_camp',
				},
			];
			areas.push(
				{
					icon: 'icon_enemy',
					obstacles: scene.shuffle(tough)[0],
				},
				...scene.shuffle([
					{
						icon: 'icon_unknown',
						obstacles: ['treasure'],
					},
					Math.random() > 0.5 && {
						icon: 'icon_unknown',
						obstacles: scene.shuffle(npc)[0],
					},
					{
						icon: 'icon_enemy',
						obstacles: scene.shuffle(tougher)[0],
					},
					Math.random() > 0.5 && {
						icon: 'icon_enemy',
						obstacles: scene.shuffle(basic)[0],
					},
					Math.random() > 0.5 && {
						icon: 'icon_enemy',
						obstacles: scene.shuffle(annoying)[0],
					},
				]),
				Math.random() > 0.5 && {
					icon: 'icon_unknown',
					obstacles: scene.shuffle(encounter)[0],
				},
				Math.random() > 0.75 && {
					icon: 'icon_enemy',
					obstacles: scene.shuffle(basic)[0],
				},
				{
					icon: 'icon_treasure',
					obstacles: ['treasure'],
				},
				Math.random() > 0.75 && {
					icon: 'icon_enemy',
					obstacles: scene.shuffle(tough)[0],
				},
				Math.random() > 0.75 && {
					icon: 'icon_enemy',
					obstacles: scene.shuffle(tougher)[0],
				},
				{
					icon: 'icon_unknown',
					obstacles: ['mini_camp'],
				},
				...scene.shuffle([
					{
						icon: 'icon_unknown',
						obstacles: ['trap'],
					},
					{
						icon: 'icon_unknown',
						obstacles: scene.shuffle(restore)[0],
					},
					Math.random() > 0.75 && {
						icon: 'icon_enemy',
						obstacles: scene.shuffle(basic)[0],
					},
					{
						icon: 'icon_enemy',
						obstacles: scene.shuffle(tough)[0],
					},
				])
			);
			areas.push(
				{
					icon: 'icon_unknown',
					obstacles: ['shrine'],
				},
				{
					icon: 'icon_boss',
					obstacles: minibossOrder[scene.level],
				},
				{
					icon: 'icon_treasure',
					obstacles: ['treasure'],
				},
				{
					icon: 'icon_door',
					obstacles: ['door'],
				}
			);
			return areas.filter((i) => i);
		},
		4: (scene) => {
			scene.setBg('bg_alternate');
			return [
				{
					icon: 'icon_camp',
				},
				{
					icon: 'icon_boss',
					obstacles: ['dragon'],
				},
				{
					icon: 'icon_unknown',
					obstacles: [
						{
							sprite: 'peach',
							interact(scene) {
								// TODO: endgame
								this.interacted = this.interacted || 0;
								if (this.interacted === 0) {
									scene.log('"Heroes! You did it!"');
									++this.interacted;
								} else if (this.interacted === 1) {
									scene.log("I haven't written an ending yet unfortunately...");
									++this.interacted;
								} else if (this.interacted === 2) {
									scene.log('Thanks for playing!');
									scene.addCard('Start');
									scene.hand.hand[
										scene.hand.hand.length - 1
									].sprCard.children[1].text = 'Restart';
									++this.interacted;
								} else {
									scene.log('Thanks for playing!');
								}
							},
						},
					],
				},
			];
		},
	};
})();
