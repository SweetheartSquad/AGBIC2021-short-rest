/**
format:
{
	sprite: 'obstacle image (uses object key if not set)',
	health: number | undefined,
	damage: number | undefined,
	shadow: false | undefined,
	start: (scene) => {
		// effect triggered when obstacle is encountered
	},
	interact: (scene) => {
		// effect triggered when obstacle is hit
	},
	end: (scene) => {
		// effect triggered when obstacle is killed
	},
}
*/
(() => ({
	door: {
		interact(scene) {
			scene.startCamp();
		},
	},
	skeleton: {
		health: 3,
		damage: 1,
	},
	bat: {
		health: 1,
		damage: 1,
	},
	treasure: {
		start() {
			// play a sound?
		},
		interact(scene) {
			scene.queue.push(async () => {
				this.animator.setAnimation('treasure_open');
				await scene.delay(100);
				scene.loot(['test', 'test', 'test']); // TODO: loot pools?
				scene.killObstacle();
			});
		},
	},
	slime_big: {
		health: 3,
		damage: 1,
		end(scene) {
			scene.addObstacle('slime_medium');
			scene.addObstacle('slime_medium');
		},
	},
	slime_medium: {
		health: 1,
		damage: 1,
		end(scene) {
			scene.addObstacle('slime_small');
			scene.addObstacle('slime_small');
		},
	},
	slime_small: {
		health: 1,
	},
	fountain_healing: {
		sprite: 'fountain',
		interact(scene) {
			scene.log('The party considers slaking their thirst.');
			scene.choice(
				{
					name: 'Slake',
					effect() {
						scene.party.forEach((i) => {
							if (i.health > 0) {
								i.heal(i.maxHealth);
							}
						});
						scene.overlay([0, 0.8, 1, 0.6], 500);
						scene.log('The party drinks, and feels refreshed.');
						scene.killObstacle();
					},
				},
				{
					name: "Don't Slake",
					effect() {
						scene.log('The party suppresses their thirst.');
						scene.killObstacle();
					},
				}
			);
		},
	},
	fountain_poison: {
		sprite: 'fountain',
		interact(scene) {
			scene.log('The party considers slaking their thirst.');
			scene.choice(
				{
					name: 'Slake',
					effect() {
						scene.party.forEach((i) => {
							i.damage(1);
						});
						scene.overlay([0.6, 0.8, 0, 0.6], 500);
						scene.log('The party drinks, and retches moments later.');
						scene.killObstacle();
					},
				},
				{
					name: "Don't Slake",
					effect() {
						scene.log('The party suppresses their thirst.');
						scene.killObstacle();
					},
				}
			);
		},
	},
	trap: {
		async interact(scene) {
			if (scene.front.name === 'Rogue') {
				scene.log('The Rogue disables the trap.');
				this.transform.y += 10;
				await scene.delay(200);
				scene.killObstacle();
			} else {
				scene.log('A trap is sprung!');
				this.animator.setAnimation('trap_triggered');
				this.transform.y += 10;
				scene.front.damage(4);
				await scene.delay(200);
				scene.killObstacle();
			}
		},
	},
	bomb: {
		sprite: 'bomb_c',
		health: 3,
		interact(scene) {
			if (this.countdown === undefined) {
				this.countdown = 3;
			}
			this.countdown -= 1;
			if (this.countdown) {
				this.animator.setAnimation(
					`bomb_${['a', 'b', 'c'][this.countdown - 1]}`
				);
			} else {
				scene.log('The bomb goes off!');
				this.animator.setAnimation('bomb');
				scene.front.damage(scene.front.health);
			}
		},
	},
	zombie: {
		health: 3,
		async interact(scene) {
			if (scene.front.name === 'Priest') {
				scene.log('The Priest banishes the zombie!');
				this.damage(3);
			} else if (this.health <= 0) {
				if (Math.random() > 0.5) {
					scene.log('The zombie got back up!');
					this.heal(3);
				}
			}
		},
	},
	dragon: {
		health: 10,
		async start(scene) {
			await scene.addObstacle('dragon_hand');
			scene.whiteout();
			scene.tween(scene.containerParty.scale, 'x', 0.6, 0);
			scene.tween(scene.containerParty.scale, 'y', 0.6, 0);
			scene.tween(scene.containerParty.pivot, 'x', -40, 0);
		},
		end(scene) {
			scene.log('"NOOO!!"');
			scene.whiteout();
			scene.tween(scene.containerParty.scale, 'x', 1, 0);
			scene.tween(scene.containerParty.scale, 'y', 1, 0);
			scene.tween(scene.containerParty.pivot, 'x', 0, 0);
		},
		async interact(scene) {
			if (this.health <= 0) {
				return;
			}
			if (scene.obstacles.length === 1) {
				await scene.addObstacle('dragon_hand');
				scene.log(
					`"${[
						scene.shuffle(['', 'Gah!', 'Argh!', 'Hrrg!', '*HISS*'])[0],
						scene.shuffle([
							'',
							'How dare you!',
							'You DARE!?',
							'Insolent!',
							"I'll get you for that!",
						])[0],
					]
						.filter((i) => i)
						.join(' ')}"`
				);
			}
		},
	},
	dragon_hand: {
		sprite: 'dragon_hand',
		health: 1,
		shadow: false,
	},
}))();
