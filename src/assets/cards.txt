(() => ({
	// menus
	init: {
		effect(scene) {
			scene.addCard('Start');
			scene.addCard('Options');
		},
	},
	Start: {
		description: 'Start a new game',
		effect(scene) {
			scene.clearHand();
			scene.clearParty();
			scene.deck.length = 0;
			scene.addDeck('refresh');
			// TODO: proper hand init
			scene.addCard('refresh');
			scene.addCard('Advance');
			scene.addParty({ name: 'Mage', spr: 'frog', maxHealth: 2 });
			scene.addParty({ name: 'Priest', spr: 'cat', maxHealth: 3 });
			scene.addParty({ name: 'Rogue', spr: 'apple', maxHealth: 2 });
			scene.addParty({ name: 'Knight', spr: 'onion', maxHealth: 4 });
			// TODO: real start
			scene.setAreas([
				'camp',
				'enemy',
				'enemy',
				'treasure',
				'unknown',
				'attention',
				'enemy',
				'treasure',
				'door',
			]);
		},
	},
	Options: {
		description: 'Edit game options',
		effect(scene) {
			scene.clearHand();
			scene.addCard('Back');
			scene.addCard('Filter');
			scene.addCard('Scale');
		},
	},
	Filter: {
		description: 'Enables/disables post-processing filter',
		effect(scene) {
			scene.screenFilter.enabled = !scene.screenFilter.enabled;
			scene.addCard('Filter');
		},
	},
	Scale: {
		description: 'Enables/disables pixel-perfect scaling',
		effect(scene) {
			window.resizer.scaleMode = {
				FIT: 'MULTIPLES',
				MULTIPLES: 'FIT',
			}[window.resizer.scaleMode];
			window.resizer.onResize();
			scene.addCard('Scale');
		},
	},
	Back: {
		description: 'Back to main menu',
		effect(scene) {
			scene.clearHand();
			scene.addCard('Start');
			scene.addCard('Options');
		},
	},
	Advance: {
		description:
			'Move, exchange blows, interact (gives another "Advance" when played)',
		effect(scene) {
			scene.addCard('Advance');
			scene.advance();
		},
	},
	Kindle: {
		description: 'Burn a card to light the campfire',
		effect(scene) {
			scene.clearHand();
			scene.deck.forEach((i, idx) => {
				scene.addCard({
					...i,
					description: `Burn "${i.name}" to light the campfire`,
					effect: () => {
						scene.camp.light();
						scene.deck.splice(idx, 1);
						scene.clearHand();
						scene.addCard('Continue');
					},
				});
			});
			scene.addCard({
				name: 'Back',
				effect: () => {
					scene.clearHand();
					scene.addCard('Kindle');
					scene.addCard('Continue');
				},
			});
		},
	},
	Continue: {
		description: 'Prepare to embark into the dungeon',
		effect(scene) {
			scene.clearHand();
			const deck = scene.deck.slice();
			scene.shuffle(deck);
			const hand = deck.splice(0, 5);
			hand.forEach((i) => {
				scene.addCard({
					...i,
					description: `Mulligan "${i.name}"`,
					effect: () => {
						scene.addCard({
							...deck.splice(0, 1)[0],
							description: "Can't mulligan a card twice",
							canPlay: () => false,
						});
					},
					canPlay: () => deck.length > 0,
				});
			});
			scene.addCard({
				name: 'Continue',
				description: 'Embark into the dungeon with this hand',
				effect(scene) {
					scene.camp.display.container.visible = false;
					scene.camp.douse();
					scene.clearHand();
					hand.forEach((i) => {
						scene.addCard(i);
					});
					scene.addCard('Advance');
					// TODO: progression
					scene.setAreas(['camp', 'enemy', 'door']);
				},
			});
			// TODO: progression
			scene.setAreas(['camp', 'enemy', 'door']);
		},
	},
	// gameplay
	test: {
		description: 'test card',
		effect() {
			console.log('test effect');
		},
		canPlay: () => true,
	},
	refresh: {
		description: 'gives cards',
		effect(scene) {
			scene.clearHand();
			scene.addCard('test');
			scene.addCard('kill');
			scene.addCard('shuffle');
			scene.addCard('Full Heal');
			scene.addCard('refresh');
			scene.addCard('Advance');
		},
		canPlay: () => true,
	},
	kill: {
		description: 'Destroys opponent',
		effect(scene) {
			scene.killObstacle();
		},
		canPlay: (scene) => scene.obstacle && scene.obstacle.health,
	},
	shuffle: {
		description: 'Shuffles party',
		effect(scene) {
			const original = scene.party.slice();
			do {
				scene.party.sort((a, b) => {
					if (a.health <= 0 && b.health > 0) return -1;
					if (a.health > 0 && b.health <= 0) return 1;
					return Math.random() - 0.5;
				});
			} while (scene.party.every((i, idx) => i === original[idx]));
		},
	},
	'Full Heal': {
		description: 'Fully heals party',
		effect(scene) {
			scene.party.forEach((i) => {
				i.heal(i.maxHealth);
			});
		},
	},
}))();
