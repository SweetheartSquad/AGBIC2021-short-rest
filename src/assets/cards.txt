(() => ({
	// menus
	init: {
		effect(scene) {
			scene.addCard('Start');
			scene.addCard('Options');
		},
	},
	Start: {
		description: 'Start a new game',
		effect(scene) {
			scene.clearHand();
			scene.clearParty();
			scene.addCard('refresh');
			scene.addCard('Advance');
			scene.addParty({ spr: 'frog', maxHealth: 2 });
			scene.addParty({ spr: 'cat', maxHealth: 3 });
			scene.addParty({ spr: 'apple', maxHealth: 2 });
			scene.addParty({ spr: 'onion', maxHealth: 4 });
			// TODO: real start
			scene.setAreas([
				'camp',
				'enemy',
				'enemy',
				'treasure',
				'unknown',
				'attention',
				'enemy',
				'treasure',
				'door',
			]);
		},
	},
	Options: {
		description: 'Edit game options',
		effect(scene) {
			scene.clearHand();
			scene.addCard('Back');
			scene.addCard('Filter');
			scene.addCard('Scale');
		},
	},
	Filter: {
		description: 'Enables/disables post-processing filter',
		effect(scene) {
			scene.screenFilter.enabled = !scene.screenFilter.enabled;
			scene.addCard('Filter');
		},
	},
	Scale: {
		description: 'Enables/disables pixel-perfect scaling',
		effect(scene) {
			window.resizer.scaleMode = {
				FIT: 'MULTIPLES',
				MULTIPLES: 'FIT',
			}[window.resizer.scaleMode];
			window.resizer.onResize();
			scene.addCard('Scale');
		},
	},
	Back: {
		description: 'Back to main menu',
		effect(scene) {
			scene.clearHand();
			scene.addCard('Start');
			scene.addCard('Options');
		},
	},
	Advance: {
		effect(scene) {
			scene.addCard('Advance');
			scene.advance();
		},
	},
	// gameplay
	test: {
		description: 'test card',
		effect() {
			console.log('test effect');
		},
		canPlay: () => true,
	},
	refresh: {
		description: 'gives cards',
		effect(scene) {
			scene.clearHand();
			scene.addCard('test');
			scene.addCard('kill');
			scene.addCard('shuffle');
			scene.addCard('Full Heal');
			scene.addCard('refresh');
			scene.addCard('Advance');
		},
		canPlay: () => true,
	},
	kill: {
		description: 'Destroys opponent',
		effect(scene) {
			scene.killObstacle();
		},
		canPlay: (scene) => scene.obstacle && scene.obstacle.health,
	},
	shuffle: {
		description: 'Shuffles party',
		effect(scene) {
			const original = scene.party.slice();
			do {
				scene.party.sort((a, b) => {
					if (a.health <= 0 && b.health > 0) return -1;
					if (a.health > 0 && b.health <= 0) return 1;
					return Math.random() - 0.5;
				});
			} while (scene.party.every((i, idx) => i === original[idx]));
		},
	},
	'Full Heal': {
		description: 'Fully heals party',
		effect(scene) {
			scene.party.forEach((i) => {
				i.heal(i.maxHealth);
			});
		},
	},
}))();
