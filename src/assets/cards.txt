/**
format:
{
	name: 'Name of Card (uses object key if not set)',
	description: 'Description text shown on hover',
	sprite: 'card image (uses name or object key if not set)',
	effect: (scene) => {
		// effect triggered when card is played
		// e.g. `scene.damageObstacle(1)` to damage obstacle in the lead by 1 hp
	},
	canPlay: (scene) => {
		// whether playing the card is allowed
		// e.g. `return false` if scene has no valid target
		return true | false;
	},
}

scene cheat sheet:

// references
scene.party // array of party members
scene.obstacles // array of obstacles
scene.front // reference to party member in front
scene.obstacle // reference to obstacle in front
scene.deck // array of card definitions in deck
scene.hand.hand // array of card definitions in hand
scene.enemy // whether there is an enemy to target
scene.alive('Name') // whether a party member is alive

// hand
scene.addCard('name' | { ...unique definition }) // adds card to hand
scene.addDeck('name' | { ...unique definition }) // adds card to deck
scene.playCard(card) // plays a card from hand
scene.clearHand() // clears cards in hand
scene.pushHand() // saves current card definitions to a stack
scene.popHand() // pops stack of card definitions and adds each (generally will want to clear hand first)
scene.loot(...card names | definitions) // gives player a choice of one card to add to their deck

// interaction
scene.addObstacle('name' | { ...unique definition })
scene.addParty({ ...unique definition })
scene.clearParty() // removes all party members
scene.choice(...card definitions) // helper for presenting choices without tracking state
scene.killObstacle() // destroys the obstacle in front
scene.killObstacle(target) // destroys specific obstacle
scene.front.damage(1)
scene.shuffle([1,2,3]); // returns a shuffled copy of the provided array

// vfx
scene.log('text') // adds text to action log
scene.announce('text', 2000) // adds big text (for bosses, etc)
scene.overlay([r,g,b,a], duration) // flashes a colour overlay
scene.blackout(duration) // shortcut for black overlay
scene.whiteout(duration) // shortcut for white overlay
scene.invert(duration) // flashes inverted overlay
scene.kick(50,50) // kicks camera
scene.shake(50,200) // shakes camera
scene.setBg('texture') // sets tiling background
scene.setFg('texture') // sets tiling foreground
await scene.delay(duration) // waits before continuing
scene.tween(target, property, to, duration, from, ease); // adds a tween

// audio
scene.sfx('name', { rate: 1, volume: 1 }) // plays sound effect (rate/volume optional)
scene.music('name', { rate: 1, volume: 1, fade: 1000 }) // plays looping music, cross-fading with any currently playing music (rate/volume/fade optional)

// progression
scene.startCamp()
scene.setLevel(level)
scene.nextLevel()
scene.advance() // basic attack/interaction/movement
*/
(() => ({
	// menus
	init: {
		effect(scene) {
			scene.setBg('title');
			scene.setFg('blank');
			scene.addCard('Start');
			scene.addCard('Options');
			scene.cardSpeed = 1;
			scene.blackout();
			scene.music('battle_theme');
		},
	},
	Start: {
		description: 'Start a new game',
		async effect(scene) {
			await scene.setLevel(0, () => {
				scene.clearHand();
				scene.clearParty();
				// TODO: proper deck init
				scene.deck.length = 0;
				scene.addDeck('refresh');
				// TODO: proper hand init
				scene.addCard('refresh');
				scene.addCard('Advance');
				scene.addParty({ name: 'Mage', spr: 'frog', maxHealth: 2 });
				scene.addParty({ name: 'Priest', spr: 'cat', maxHealth: 3 });
				scene.addParty({ name: 'Rogue', spr: 'apple', maxHealth: 2 });
				scene.addParty({ name: 'Knight', spr: 'onion', maxHealth: 4 });
				scene.setBg('bg');
				scene.setFg('fg');
			});
		},
	},
	Options: {
		description: 'Edit game options',
		effect(scene) {
			scene.clearHand();
			scene.addCard('Back');
			scene.addCard('Filter');
			scene.addCard('Scale');
			scene.addCard('Card Throw');
		},
	},
	Filter: {
		description: 'Enables/disables post-processing filter',
		effect(scene) {
			scene.screenFilter.enabled = !scene.screenFilter.enabled;
			scene.addCard('Filter');
			scene.hand.hand.splice(1, 0, scene.hand.hand.pop()); // keep cards in order
		},
	},
	Scale: {
		description: 'Enables/disables pixel-perfect scaling',
		effect(scene) {
			window.resizer.scaleMode = {
				FIT: 'MULTIPLES',
				MULTIPLES: 'FIT',
			}[window.resizer.scaleMode];
			window.resizer.onResize();
			scene.addCard('Scale');
			scene.hand.hand.splice(2, 0, scene.hand.hand.pop()); // keep cards in order
		},
	},
	'Card Throw': {
		description: 'Enables/disables card play animation',
		effect(scene) {
			scene.cardSpeed = scene.cardSpeed ? 0 : 1;
			scene.addCard('Card Throw');
		},
	},
	Back: {
		description: 'Back to main menu',
		effect(scene) {
			scene.clearHand();
			scene.addCard('Start');
			scene.addCard('Options');
		},
	},
	Advance: {
		description:
			'Move, exchange blows, interact (gives another "Advance" when played)',
		effect(scene) {
			scene.addCard('Advance');
			scene.advance();
		},
	},
	Kindle: {
		description: 'Burn a card to light the campfire and heal the party',
		canPlay(scene) {
			return scene.deck.length > 0;
		},
		effect(scene) {
			scene.clearHand();
			scene.deck.forEach((i, idx) => {
				scene.addCard({
					...i,
					description: `Burn "${i.name}"`,
					canPlay: undefined,
					effect: () => {
						scene.camp.light();
						scene.log(
							`The party basks in the warmth of "${i.name}" and regains their strength.`
						);
						scene.party.forEach((i) => i.heal(i.maxHealth));
						scene.overlay([1, 0.5, 0, 0.5]);
						scene.deck.splice(idx, 1);
						scene.clearHand();
						scene.addCard({
							name: 'Kindle',
							description: 'Campfire already kindled.',
							canPlay() {
								return false;
							},
						});
						scene.addCard('Continue');
					},
				});
			});
			scene.addCard({
				name: 'Back',
				effect: () => {
					scene.clearHand();
					scene.addCard('Kindle');
					scene.addCard('Continue');
				},
			});
		},
	},
	Continue: {
		description: 'Prepare cards to embark into the dungeon',
		effect(scene) {
			scene.clearHand();
			const deck = scene.deck.slice();
			scene.shuffle(deck);
			const hand = deck.splice(0, 5);
			hand.forEach((i) => {
				scene.addCard({
					...i,
					description: `Mulligan "${i.name}"`,
					effect: () => {
						scene.addCard({
							...deck.splice(0, 1)[0],
							description: "Can't mulligan a card twice",
							canPlay: () => false,
						});
					},
					canPlay: () => deck.length > 0,
				});
			});
			scene.addCard({
				name: 'Continue',
				description: 'Prepare party to embark into the dungeon with this hand',
				effect(scene) {
					scene.clearHand();
					const party = scene.party.slice();
					const order = [];
					const positions = ['the lead'];
					positions[party.length - 1] = 'the back';
					const embark = () => {
						scene.nextLevel(() => {
							scene.clearHand();
							hand.forEach((i) => {
								scene.addCard(i);
							});
							scene.addCard('Advance');
						});
					};

					// party order selection
					const partyOrder = () => {
						if (party.length > 0) {
							scene.clearHand();
							party.forEach((i) => {
								const idx = scene.party.length - party.length;
								const position = positions[idx] || `position ${idx + 1}`;
								scene.addCard({
									name: i.name,
									description: `Put ${i.name} in ${position}`,
									effect: () => {
										party.splice(party.indexOf(i), 1);
										order.push(i);
										partyOrder();
									},
								});
							});
							if (party.length === scene.party.length) {
								scene.addCard({
									name: 'Continue',
									description:
										'Embark into the dungeon without changing party order',
									effect: embark,
								});
							}
							return;
						}
						scene.party = order.reverse();
						scene.addCard({
							name: 'Continue',
							description: 'Embark into the dungeon',
							effect: embark,
						});
					};
					partyOrder();
				},
			});
		},
	},
	// gameplay
	test: {
		description: 'test card',
		effect() {
			console.log('test effect');
		},
		canPlay: () => true,
	},
	refresh: {
		description: 'gives cards',
		effect(scene) {
			scene.clearHand();
			scene.addCard('test');
			scene.addCard('kill');
			scene.addCard('shuffle');
			scene.addCard('Full Heal');
			scene.addCard('refresh');
			scene.addCard('Advance');
		},
		canPlay: () => true,
	},
	kill: {
		description: 'Destroys opponent',
		effect(scene) {
			scene.killObstacle();
		},
		canPlay: (scene) => scene.enemy,
	},
	shuffle: {
		description: 'Shuffles party',
		effect(scene) {
			const original = scene.party.slice();
			do {
				scene.party.sort((a, b) => {
					if (a.health <= 0 && b.health > 0) return -1;
					if (a.health > 0 && b.health <= 0) return 1;
					return Math.random() - 0.5;
				});
			} while (scene.party.every((i, idx) => i === original[idx]));
		},
	},
	'Full Heal': {
		description: 'Fully heals party',
		effect(scene) {
			scene.party.forEach((i) => {
				i.heal(i.maxHealth);
			});
		},
	},
	Slash: {
		description: 'The Knight slashes for 1 damage',
		canPlay(scene) {
			return scene.enemy && scene.enemy('Knight');
		},
		effect(scene) {
			scene.obstacle.damage(1);
			scene.kick(-5);
		},
	},
	'Twin Daggers': {
		description: 'The Rogue throws two daggers, each dealing 1 damage',
		canPlay(scene) {
			return scene.enemy && scene.party('Rogue');
		},
		effect(scene) {
			scene.obstacle.damage(1);
			scene.kick(-5);
			scene.delay(100).then(() => {
				if (scene.enemy) {
					scene.kick(-5);
					scene.obstacle.damage(1);
				}
			});
		},
	},
	'Magic Blast': {
		description: 'The Mage fires a blast, dealing 2 damage',
		canPlay(scene) {
			return scene.enemy && scene.party('Mage');
		},
		effect(scene) {
			scene.obstacle.damage(2);
			scene.kick(-5);
			scene.overlay([1, 0, 1, 0.5]);
		},
	},
	Bonk: {
		description: 'Bonk an enemy for 1 damage',
		canPlay(scene) {
			return scene.enemy;
		},
		effect(scene) {
			scene.obstacle.damage(1);
			scene.kick(-5);
		},
	},
	'Death from the Shadows': {
		description: 'The Rogue kills an enemy',
		canPlay(scene) {
			return scene.enemy && scene.alive('Rogue');
		},
		effect(scene) {
			scene.kick(-50);
			scene.killObstacle();
			scene.blackout();
		},
	},
	Exorcise: {
		description: 'The Priest destroys all undead enemies',
		canPlay(scene) {
			return scene.enemy && scene.alive('Priest');
		},
		effect(scene) {
			const undead = ['skeleton', 'skeleton_armoured', 'zombie', 'necromancer'];
			scene.shake(5, 1000);
			scene.whiteout(1000);
			scene.obstacles
				.filter((i) => undead.includes(i.def.name))
				.forEach((i) => {
					i.damage(i.maxHealth, true);
				});
		},
	},
	'Vision of Death': {
		description: 'The Mage kills everything in sight',
		canPlay(scene) {
			return scene.alive('Mage');
		},
		effect(scene) {
			scene.obstacles.slice().forEach((i) => {
				i.damage(i.maxHealth, true);
			});
			const mageIndex = scene.party.findIndex((i) => i.name === 'Mage');
			scene.party.slice(mageIndex + 1).forEach((i) => {
				i.damage(i.maxHealth);
				scene.log(`${i.name} is caught in the line of sight!`);
			});
			scene.shake(5, 1000);
			scene.kick(-50);
			scene.overlay([1, 0, 1, 0.5], 1000);
		},
	},
	'Portable Mulligan': {
		description: 'Replace all cards in your hand with new ones from your deck',
		effect(scene) {
			const cards = scene.hand.hand.length - 1; // -1 for advance
			const draw = scene.shuffle(scene.deck.slice());
			scene.clearHand();
			for (let i = 0; i < cards && draw.length; ++i) {
				scene.addCard(draw.pop());
			}
			scene.addCard('Advance');
		},
	},
	'Charm Creature': {
		description: 'The Priest sways a creature to switch sides',
		canPlay(scene) {
			return scene.enemy && scene.alive('Priest');
		},
		effect(scene) {
			const o = scene.obstacle;
			// TODO: limit charmable creatures
			const p = scene.addParty({
				name: `Friendly ${o.def.name}`,
				spr: o.def.sprite,
				maxHealth: o.maxHealth,
				health: o.health,
				temporary: true,
			});
			p.sprBody.scale.x = -1;
			p.sprOL.scale.x = -1;
			scene.killObstacle(o);
		},
	},
	'Summon Fire Sprite': {
		description: 'The Mage Summons a 1HP creature to fight alongside the party',
		canPlay(scene) {
			return scene.alive('Mage');
		},
		effect(scene) {
			scene.addParty({
				name: 'Fire Sprite',
				spr: 'icon_camp',
				maxHealth: 1,
				temporary: true,
			});
			scene.whiteout();
		},
	},
	'Poly Morph': {
		description: 'The Mage transforms a creature into another',
		canPlay(scene) {
			return scene.enemy && scene.alive('Mage');
		},
		effect(scene) {
			// TODO: polymorph targets
			const result = scene.shuffle([
				'rat_small',
				'slime_small',
				'bat',
				'rat_small',
				'slime_small',
				'bat',
				'skeleton',
				'zombie',
				'bomb',
			])[0];
			scene.log(`${scene.obstacle.def.name} morphed into a ${result}!`);
			scene.killObstacle();
			scene.addObstacle(result);
			scene.overlay([1, 0, 1]);
		},
	},
	'Invoke Augur': {
		description: 'The Priest prompts an encounter in an empty room',
		canPlay(scene) {
			return !scene.obstacle;
		},
		effect(scene) {
			const result = scene.shuffle([
				['fountain'],
				['treasure'],
				['potion'],
				['fortune_teller'],
				['skeleton', 'A bad omen...'],
				['zombie', 'A bad omen...'],
				['skeleton_armoured', 'A bad omen...'],
			])[0];
			scene.whiteout();
			scene.addObstacle(result[0]);
			if (result[1]) {
				scene.log(result[1]);
			}
		},
	},
}))();
